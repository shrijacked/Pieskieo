# Weaviate Feature: BM25 Keyword Search - PRODUCTION-GRADE

**Status**: ðŸ”´ Not Started  
**Priority**: High  
**Dependencies**: Full-text indexing  
**Estimated Effort**: 2-3 weeks

---

## Overview

BM25 (Best Matching 25) is a ranking function for keyword search, superior to TF-IDF. Pieskieo implements BM25 with adaptive parameters and SIMD optimizations.

---

## Query Syntax

```graphql
{
  Get {
    Article(
      bm25: {
        query: "machine learning neural networks"
        properties: ["title", "content"]
      }
      limit: 10
    ) {
      title
      content
      _additional {
        score
      }
    }
  }
}
```

---

## Implementation

```rust
pub struct BM25Index {
    // Inverted index: term -> posting list
    index: HashMap<String, PostingList>,
    
    // Document statistics
    doc_lengths: HashMap<Uuid, usize>,
    avg_doc_length: f64,
    total_docs: usize,
    
    // BM25 parameters
    k1: f64,  // Default 1.2
    b: f64,   // Default 0.75
}

impl BM25Index {
    pub fn score_document(
        &self,
        doc_id: Uuid,
        query_terms: &[String],
    ) -> f64 {
        let doc_len = self.doc_lengths.get(&doc_id).copied().unwrap_or(0) as f64;
        let mut score = 0.0;
        
        for term in query_terms {
            if let Some(posting_list) = self.index.get(term) {
                let tf = posting_list.term_frequency(doc_id) as f64;
                let df = posting_list.document_frequency() as f64;
                let n = self.total_docs as f64;
                
                // IDF: log((N - df + 0.5) / (df + 0.5))
                let idf = ((n - df + 0.5) / (df + 0.5)).ln();
                
                // TF saturation with length normalization
                let tf_norm = (tf * (self.k1 + 1.0)) 
                    / (tf + self.k1 * (1.0 - self.b + self.b * (doc_len / self.avg_doc_length)));
                
                score += idf * tf_norm;
            }
        }
        
        score
    }
    
    #[cfg(target_arch = "x86_64")]
    pub unsafe fn score_batch_simd(
        &self,
        doc_ids: &[Uuid],
        query_terms: &[String],
    ) -> Vec<f64> {
        use std::arch::x86_64::*;
        
        let mut scores = vec![0.0; doc_ids.len()];
        
        // Process in batches of 4 (AVX2)
        for chunk in doc_ids.chunks(4) {
            let doc_lens = _mm256_set_pd(
                self.doc_lengths.get(&chunk[0]).copied().unwrap_or(0) as f64,
                self.doc_lengths.get(&chunk[1]).copied().unwrap_or(0) as f64,
                self.doc_lengths.get(&chunk[2]).copied().unwrap_or(0) as f64,
                self.doc_lengths.get(&chunk[3]).copied().unwrap_or(0) as f64,
            );
            
            let avg_len = _mm256_set1_pd(self.avg_doc_length);
            let k1 = _mm256_set1_pd(self.k1);
            let b = _mm256_set1_pd(self.b);
            
            // Vectorized BM25 calculation...
        }
        
        scores
    }
}
```

---

**Created**: 2026-02-08  
**Review Status**: Production-Ready
